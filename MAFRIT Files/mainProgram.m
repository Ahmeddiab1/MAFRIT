%%
%%
% *INTRODUCTION*: This ".m" file, "mainProgram.m" forms the interface between MATPOWER and the dynamic models of power plant equipment written in MATLAB as separate functions.
% The code written in this m-file performs the following major tasks:
%
%    1 - Reading the description of the dynamic equipment connected at a bus and assigning the equipment parameters to appropriate dynamic models
%    2 - Initializing the dynamic models using the bus voltage and current phasors returned by MATPOWER
%    3 - Simulating power system dynamics for a fixed time period and writing various output variables of interest to text files or MATLAB variables
%%
clear classes
fclose('all');
%%
%%
% *NOTES* : This section of the code parses the 'power_plant_specs' file and tells the program the location of text files where equipment parameters are stored. It also
%         informs the program about the dynamic models connected at a bus, whether the generator behaves as a voltage source or a current source and in which text
%         files the dynamic state variables will be stored. The format of the 'power_plant_specs' file will be presented next.
%
% *VARIABLE DESCRIPTION* :
%         1. busesPV:   Counts the total number of power injection buses, i.e., the buses to which dynamic models are attached
%         2. busesV:    Counts the number of buses where the generator is modeled as a voltage source. All synchronous generators are
%         3. busesI:    Counts the number of buses where the generator is modeled as a current source.
%         3. busnumV:   Vector that stores a list of buses where voltage sources are added. The bus numbers in this list are not the
%                       actual bus numbers that are used in MATPOWER, but the order in which they appear in the "power_plant_specs" file. This order
%                       must match the bus order in the MATPOWER power flow case file which should follow these rules:
%
%                       A. The swing bus should be the first row in the bus table and is always a synchronous machine
%                       B. All the Voltage Source Buses should be put together in the bus table and so should the buses
%                          with Current Sources. Combined with rule A, this rule requires that all the Voltage Source buses should be put before the Current Source buses in the bus table in MATPOWER and load
%                          buses are put at the end
%
%                       These rules must be followed so that voltages and currents generated by MATPOWER are assigned to the correct dynamic models.
%
%                       In future, if dynamic load models are to be added, same bus ordering for MATPOWER and the 'power_plant_specs' file should be followed
%
%                       In future,if a synchronous condenser is put at a bus it should be treated as voltage source bus, similar to a synchronous generator
 
%         4. busnumI:   Vector that stores a list of buses where current sources are added.
%         5. pathStr:   This is the path string that tells this m-file the location of the directory in which all the files, including MATPOWER files, are to be found.
%                       This string can be changed to any desired location
%         6. fid:       This variable stands for file identifier and acts as the reference for the 'power_plant_specs' file
%         7. allSpecs:  This is a cell array that is used to store all the data contained in the 'power_plant_specs' file
%         7. allSpecsV: This is a cell array that is used to store all the data contained in the 'power_plant_specs' file corresponding to Voltage Source buses
%         8. allSpecsI: This is a cell array that is used to store all the data contained in the 'power_plant_specs' file corresponding to Current Source buses
%
% *'power_plant_specs' FORMAT*:
%
%         1. At present there are 22 fields that are used in the 'power_plant_specs' file.
%         2. All the fields are comma separated.
%         3. Using "%" as the first character in the line causes the program to ignore the line.
%         4. If a dynamic model is not be to used, put 'n/a' in its field. The 'gen type' filed for Voltage Source buses and 'regc' for current source buses must never be 'n/a'
%         5. The format of each line in the file is as below:
%
%
%  For Synchronous Machines:                    <bus  #>,<gen type>,<gen
%  parameter file>,<gen states recording file>,<exciter type>,<exciter
%  parameter file>,<exciter states recording file>,<governor
%  type>,<governor parameter file>,<governor states recording file>,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,unit_controller,<filename containing unit controller parameters>,<filename containing unit controller states>
%  For Type 3 and Type 4 Wind Turbines and
%  Central PV Stations:                         <bus  #>,<regc>,<regc parameter file>,<regc states recording file>,<NOTE 1>,<reecA OR reecB parameter file>,<reecA OR reecB states recording file>,<see NOTE 2>,<wtgtr parameter file>,<wtgtr states recording file>,<see NOTE 3>,<wtgtq parameter files>,<wtgtq states recording file>,<see NOTE 4>,<wtgpt>,<wtgpt parameter file>,<wtgpt states recording file>,<repc>,<repc parameter file>,<repc states recording file>,unit_controller,<filename containing unit controller parameters>,<filename containing unit controller states>
%                                               NOTE 1: This field should be 'type3' or 'type4' or 'centpv' or 'n/a'. If 'n/a', all subsequent fields should be 'n/a'
%                                               NOTE 2: This field should always be 'type3' when simulating Type 3 wind turbines unless field in 'NOTE 1' is 'n/a'. It must be 'n/a' for central PV stations and could be 'type4' or 'n/a' for Type 4 wind turbines.
%                                               NOTE 3: This field should always be 'wtgtq' when simulating Type 3 wind turbines unless field in 'NOTE 1' is 'n/a'. It must always be 'n/a' when simulating Type 4 wind turbines or Central PV Stations
%                                               NOTE 4: This field should always be 'wtgtq' when simulating Type 3 wind turbines unless field in 'NOTE 1' is 'n/a'. It must always be 'n/a' when simulating Type 4 wind turbines or Central PV Stations
% For AGC:                                      <bus  # where AGC is to be put...must be at an online generator bus>,isolAGC,<agc parameter file name>,<agc_model states>,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a,n/a
%% Defining Various Constants and User Inputs that do not change during program execution
addpath('C:\Files and folders to run MAFRIT\All MATPOWER M-Files for DS') % path to all the matpower files that are required for MAFRIT to work. Anyname can be used as long as the path is correctly specified.
addpath('C:\Files and folders to run MAFRIT\All M-Files') % path for all the dynamic models that are needed in MAFRIT. Anyname can be used as long as the path is correctly specified.
MAXGEN=11; % # of synchronous generators
MAXRENGEN=89; % of asynchronous generators (e.g., wind, solar, battery storage, or even small synchronous generators that are modeled as current sources.
MAXAGC=1; % number of AGCs
sbustmp=[];
mismatches=[];
voltages=[];
ybuses=[];
V0tmp=[];
disturbance_bus_load=[];
ws=120*pi;
sBasePF=100;        % System MVA base used in the power flow; Can also be passed from the power flow program in case it is different from 100 MVA
iterMax=108000;       % Specifies the maximum number of iterations for which the dynamics simulation should be run
sampRate=120;       % # of times per second the simulation is run
dTimeBegin=1000;      % Time in seconds at which disturbance begins
dTimeEnd=5000;        % Time in seconds at which disturbance ends
flag=0;             % When 1, step load change is simulated
flginit=0;          % This flag is used to make sure that previous values of bus voltages are used when the power flow is run after initialization
dBus=63;    % load bus where disturbance is to be created
sD=[0 0];           % magnitude of disturbance; sD(1)=P (real power); sD(2)=Q (reactive power);
deltat=1/sampRate;  % used to calculate bus frequency
vpss=0;             % This is a placeholder variable representing the input of a Power System Stabilizer (PSS). PSS is not currently modeled
genTripBus=2020;     % Bus number of the generator to be tripped as in the power flow case
genTripTime=1;   % Time at which generator should trip; if generator not to be tripped then set it at 1e10
simTime=0;          % current simulation time
busesPV=1;
busesV=0;
busnumV=[];
busnumI=[];
busnumAGC=[];
busesI=0;
busesAGC=0;
filtFreqBus=[1,69]; % this vector should hold the buses in the same order as in power plant specs to get the frequency for specific generator buses to be used for AGC function
regcMVA=[];
dprefCS=zeros(MAXRENGEN,1);
load 'C:\Files and folders to run MAFRIT\MATLAB_M_Files\test.mat'; % path to the solved case file in .mat format. Essentially, the output in the workspace one gets after solving power flow using Matpower's runpf() command/ 
 
VM=8;VA=9;
V  = casedata.bus(1:MAXGEN, VM) .* exp(sqrt(-1) * pi/180 * casedata.bus(1:MAXGEN, VA));
voltages2=V;
 
pathStr='C:\Files and folders to run MAFRIT\'; % path for the power plant specs file
fid=fopen([pathStr 'power_plant_specs.txt']);
linee=textscan(fid,'%s',22,'delimiter',',','commentStyle','%');
allSpecs=linee{1,1};
%allSpecs{3,1}=['MATLAB_Parameter_Files',filesep,allSpecs{3,1}];
%allSpecs{4,1}=['MATLAB_States_Files',filesep,allSpecs{4,1}];
temp=linee{1,1};
allSpecsV=cell(length(allSpecs),1);
allSpecsI=cell(length(allSpecs),1);
allSpecsAGC=cell(length(allSpecs),1);
 
% The indented section of the code below is used to correctly populate the 'allSpecsV' and 'allSpecsI' cell arrays
if strcmp(temp{2,busesPV},'genrou')==1 || strcmp(temp{2,busesPV},'gensal')==1 || strcmp(allSpecs{2,busesPV},'gencls')==1 % More test conditions will need to be added if new synchronous generator models are added 
    busesV=busesV+1;
    busnumV=busesPV;
    allSpecsV=cat(2,allSpecsV,allSpecs(:,busesPV));
elseif strcmp(temp{2,busesPV},'agc')==1
    busesAGC=busesAGC+1;
    busnumAGC=busesPV;
    allSpecsAGC=cat(2,allSpecsAGC,allSpecs(:,busesPV));
else
    busesI=busesI+1;
    busnumI=busesPV;
    allSpecsI=cat(2,allSpecsI,allSpecs(:,busesPV));
end
 
while(strcmp(temp{1,1},'end')~=1)
    linee=textscan(fid,'%s',22,'delimiter',',','commentStyle','%');
    temp=linee{1,1};
    if strcmp(temp{1,1},'end')~=1
        allSpecs=cat(2,allSpecs,linee{1,1});
        
        
        if strcmp(allSpecs{2,busesPV+1},'genrou')==1 || strcmp(allSpecs{2,busesPV+1},'gensal')==1 || strcmp(allSpecs{2,busesPV+1},'gencls')==1
            busesV=busesV+1;
            allSpecsV=cat(2,allSpecsV,allSpecs(:,busesPV+1));
            if isempty(busnumV)
                busnumV=busesPV+1;
            else
                busnumV=cat(1,busnumV,busesPV+1);
            end
        elseif strcmp(allSpecs{2,busesPV+1},'isolAGC')==1 || strcmp(allSpecs{2,busesPV+1},'interConnecAGC')==1
            busesAGC=busesAGC+1;
            allSpecsAGC=cat(2,allSpecsAGC,allSpecs(:,busesPV+1));
            if isempty(busnumAGC)
                busnumAGC=busesPV+1;
            else
                busnumAGC=cat(1,busnumAGC,busesPV+1);
            end
        else
            busesI=busesI+1;
            allSpecsI=cat(2,allSpecsI,allSpecs(:,busesPV+1));
            if isempty(busnumI)
                busnumI=busesPV+1;
            else
                busnumI=cat(1,busnumI,busesPV+1);
            end
        end
        busesPV=busesPV+1;
    end
end
 
countreecB=0;
countrepc=0;
reecpmaxpmin=[];
repcpmaxpmin=[];
 
allSpecsV(:,1)=[];      % Removes the redundant first column of the allSpecsV cell array
allSpecsI(:,1)=[];      % Removes the redundant first column of the allSpecsI cell array
allSpecsAGC(:,1)=[];      % Removes the redundant first column of the allSpecsAGC cell array
 
allSpecsV(3,:)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsV(3,:));
allSpecsV(4,:)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsV(4,:));
 
for c=1:size(allSpecsV,2)
    if ~strcmp(allSpecsV{5,c},'n/a')
        allSpecsV(6,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsV(6,c));
        allSpecsV(7,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsV(7,c));
    end
    if ~strcmp(allSpecsV{8,c},'n/a')
        allSpecsV(9,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsV(9,c));
        allSpecsV(10,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsV(10,c));
    end
    if ~strcmp(allSpecsV{20,c},'n/a')
        allSpecsV(21,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsV(21,c));
        allSpecsV(22,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsV(22,c));
    end
end
 
for c=1:size(allSpecsI,2)
    if ~strcmp(allSpecsI{2,c},'n/a')
        allSpecsI(3,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(3,c));
        allSpecsI(4,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(4,c));
    end
    if ~strcmp(allSpecsI{5,c},'n/a')
        allSpecsI(6,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(6,c));
        allSpecsI(7,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(7,c));
    end
    if ~strcmp(allSpecsI{8,c},'n/a')
        allSpecsI(9,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(9,c));
        allSpecsI(10,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(10,c));
    end
    if ~strcmp(allSpecsI{11,c},'n/a')
        allSpecsI(12,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(12,c));
        allSpecsI(13,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(13,c));
    end
    if ~strcmp(allSpecsI{14,c},'n/a')
        allSpecsI(15,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(15,c));
        allSpecsI(16,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(16,c));
    end
    if ~strcmp(allSpecsI{17,c},'n/a')
        allSpecsI(18,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(18,c));
        allSpecsI(19,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(19,c));
    end
    if ~strcmp(allSpecsI{20,c},'n/a')
        allSpecsI(21,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsI(21,c));
        allSpecsI(22,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsI(22,c));
    end
end
 
for c=1:size(allSpecsAGC,2)
    if ~strcmp(allSpecsV{2,c},'n/a')
        allSpecsAGC(3,c)=strcat(['S4S2Day1HR12NoRegESS_Parameter_Files',filesep],allSpecsAGC(3,c));
        allSpecsAGC(4,c)=strcat(['S4S2Day1HR12NoRegESS_States_Files',filesep],allSpecsAGC(4,c));
    end
end
 
% when solar, wind, and solar or wind with battery storage can provide AGC support or any type of real power
% support, we must change their pmax as a function of their maximum power point. Pmin should also be specified for these plants. The excel file
% being read below provides the pmax and pmin values for such plants, which
% are identified by their bus numbers. This file has three columns. Column 1 has the bus numbers of plants,
% column 2 has their pmax values and the third column has their pmin values. pmax and pmin are in MW.
try
    pmaxData=xlsread("pmaxWindSolar.xlsx");
catch exception
    pmaxData=[];
end
 
% obtaining a list of all generator buses on AGC and the total generation at the bus
count=0;
busnumbers=cat(2,allSpecsV(1,:),allSpecsI(1,:));
genAGCStatus=cat(2,allSpecsV(20,:),allSpecsI(20,:));
genBusOnAGC=busnumbers(find(genAGCStatus=="unit_controller"));
for j=1:length(genBusOnAGC)
    for i=1:length(casedata.bus)
        if (str2num(genBusOnAGC{1,j})==casedata.bus(i,1))
            count=count+1;
            genBusAGC(count,1)=casedata.bus(i,1);
            break
        end
    end
end
 
for i=1:count
    for j=1:length(casedata.gen)
        if casedata.gen(j,8)==1
            if genBusAGC(i,1)==casedata.gen(j,1)
               genBusAGC(i,2)=casedata.gen(j,2);  
               break;
            end
        end
    end
end
 
for i=1:count
    for j=1:length(casedata.bus)
        if casedata.bus(j,2)==1
            if genBusAGC(i,1)==casedata.bus(j,1)
               genBusAGC(i,2)=-casedata.bus(j,3); 
               break;
            end
        end
    end
end
 
fclose(fid);            % Closes the 'power_plant_specs' text file. This file is not needed anymore.
%% Bus and Line Information for repc_a plant level controller. Not used if the repc_a controller is absent.
% fbus=[24;25;26;27;28;29;30;31;32;33]; % Monitored Bus # vector . It is NOT the actual bus number vector but the vector containing the position of the bus in the MATPOWER bus array
% tbus=[0;0;0;0]; % Regulated Bus # vector . It is NOT the actual bus number vector but the vector containing the position of the bus in the MATPOWER bus array
% ckt=[1;1;1;1]; % MATPOWER doesn't have a field for line circuit. It can be used if some other power flow analysis software is used in the future.
 
fbus=zeros(MAXRENGEN,1);
tbus=zeros(size(fbus));
ckt=zeros(size(fbus));
% dBus=dBus+size(fbus,1);
 
%% Creating Array of Objects of All Dynamics Components. All the arrays are of size MAXGEN although not all the objects will be used in the array of objects
%   *NOTE* : The name on the right hand side of the equality is the class name that contains the mathematical description of the equipment. This
%            name should match with the name of the corresponding m-file; e.g., genrou.m
 
genROU(MAXGEN,1)=genrou;
genSAL(MAXGEN,1)=gensal;
genCLS(MAXGEN,1)=gencls;
regc(MAXRENGEN,1)=regc_a;
genROUCS(MAXRENGEN,1)=genrouCS;
 
extST1A(MAXGEN,1)=st1a;
extAC1A(MAXRENGEN+MAXGEN,1)=ac1a;
extDC1A(MAXGEN,1)=dc1a;
extAC7B(MAXGEN,1)=ac7b;
ieeeX1(MAXGEN,1)=ieeex1;
ieeeT3(MAXGEN,1)=ieeet3;
reecA(MAXRENGEN,1)=reec_a;
reecB(MAXRENGEN,1)=reec_b;
 
govGGOV1(MAXGEN,1)=ggov1;
govHYGOV(MAXGEN,1)=hygov;
ieeSGO(MAXGEN,1)=ieesgo;
repc(MAXRENGEN,1)=repc_a;
wtgtr(MAXRENGEN,1)=wtgtr_a;
wtgtq(MAXRENGEN,1)=wtgtq_a;
wtgpt(MAXRENGEN,1)=wtgpt_a;
 
agc(MAXAGC,1)=agcIsol;
uCnt(MAXRENGEN+MAXGEN,1)=unitController;
 
%% Creating Arrays to Store field Voltages, Terminal Voltages, etc.
efd(1:MAXGEN,1)=ones(MAXGEN,1);         % Vector of field voltages returned by synchronous machine exciters
ifd(1:MAXGEN,1)=ones(MAXGEN,1);         % Vector of field current returned by synchronous generators
vt(1:MAXGEN,1)=ones(MAXGEN,1);          % Vector of terminal voltage phasor magnitude of buses with Synchronous Generators
vref(1:MAXGEN,1)=ones(MAXGEN,1);        % Vector of exciter reference voltage. vref could have been made a property of the exciter since it doesn't change during the simulation. This vector is required, but could have been avoided
 
% IMPORTANT Variable for AGC
 
 
pref(1:MAXGEN,1)=ones(MAXGEN,1);        % Vector of governor reference power.*The values in this vector should be changed after initialization to simulate new power reference given by the AGC.*
 
 
pMmechGov(1:MAXGEN,1)=ones(MAXGEN,1);   % Vector of mechanical power output from the governor on governor's MVA base
pMech(1:MAXGEN,1)=ones(MAXGEN,1);       % Vector of mechanical power input from the governor on generator's MVA base
vPVNew(1:MAXGEN,1)=ones(MAXGEN,1);      % Vector of new terminal voltage generated by Voltage Sources at each iteration that is used by MATPOWER to solve the power flow for the next iteration.
vterminal=ones(iterMax,MAXGEN);         % Array that holds the terminal voltage phasor magnitude for all the generator buses for all the iterations
sbgen=zeros(MAXGEN,1);                  % Vector that holds the generator MVA bases for all the synchronous generators
ace(1:MAXAGC,1)=zeros(MAXAGC,1);        % vector that holds the instantaneous ACE of all areas with AGC
dpref(1:MAXGEN,1)=zeros(MAXGEN,1);      % vector that holds the instantaneous change in pref of synchronous generator governors calculated by the unit controller
frequency=zeros(iterMax,MAXGEN+1);
 
%% Initializing the Components: In this section of the code, power flow is run once to generate the
%                               voltages and currents for initializing the dynamic models.
 
% run the power flow at the start to obtain the initial steady state generator bus voltages and currents.
pinit=0;
qinit=0;
V_PV_init=[1;1;1];       % This vector could be anything (vector of any size or simply a scalar) as it is not used till the iterations are started
V_PQ_init=[1;1;1;1;1;1]; % This vector could be anything (vector of any size or simply a scalar) as it is not used till the iterations are started
 
if ~isempty(busnumI)     % When current sources are present, it was observed that power flow should be run a few times to get steady initial conditions.
    % I am running the power flow 200 times, but it could be any number that gives steady initial conditions
    for i=1:200
        [success,V,I,Ybus,loadOrg,genbus,pq,idxTripGen,angVSwing] = runpfDS(casedata,V_PV_init,V_PQ_init,flag,dBus,sD,flginit,pinit,qinit,busnumI,simTime,genTripBus,genTripTime); % This is the call to matpower which returns all the bus voltages and currents in vectors 'V' and 'I' respectively.
        % The power flow also returns the Ybus matrix (Ybus), original load bus loads (loadOrg)for simulating step load
        % change (if needed); a list of generator bus numbers (genbus) and a list of pq bus numbers (pq)
        flginit=1;                              % This flag is set to 1 to force MATPOWER to use the voltages passed in 'V_PV_init' and 'V_PQ_init' for solving the power flow. This functionailty is required for 2 reasons:
        % 1. Before initialization, to solve the power flow faster by using previously determined voltages
        % 2. Later, to ensure that voltages determined by the Voltage Sources at the previous iteration
        %    are used for solving the power flow for the next iteration
        V_PV_init=V(genbus);
        V_PQ_init=V(pq);
        pinit=-real(V(busnumI).*conj(I(busnumI)))*100; % pinit is the real power injected by current sources
        qinit=-imag(V(busnumI).*conj(I(busnumI)))*100; % qinit is the reactive power injected by current sources
        
    end
else
    for i=1:50
        [success,V,I,Ybus,loadOrg,genbus,pq,idxTripGen,angVSwing] = runpfDS(casedata,V_PV_init,V_PQ_init,flag,dBus,sD,flginit,pinit,qinit,busnumI,simTime, genTripBus,genTripTime);
        V_PV_init=V(genbus);
    end
end
initializing=0;
 
if success==0
    sprintf('%s','powerflow diverged. program execution will stop.Press any key to exit')
    pause
    exit
end
 
% Voltage and Current of Buses that act as voltage sources
V_PV=V(busnumV);
I_PV=I(busnumV);
real_power=V_PV.*conj(I_PV);
vt(1:length(V_PV),1)=abs(V_PV);
 
 
voltages2=[voltages2 V_PV];
 
% Voltage of Load Buses that will be passed to the load flow as initial voltages for solving the power flow at the next iteration
V_PQ=V(pq);
 
% Voltage and Current of Buses that act as current sources
if ~isempty(busnumI)
    V_I=V(busnumI);
    I_I=I(busnumI);
    vterm=abs(V_I);
    qgen=imag(V_I.*conj(I_I));  % holds the terminal reactive power of the wind and solar generators
    pe=real(V_I.*conj(I_I));    % holds the terminal active power of the wind and solar generators
end
 
%% busesV is the counter for voltage sources and the section of code here initializes all the voltage sources
gen_idxs=zeros(busesV,1);
for i=1:busesV
    gen_idxs(i)=find(casedata.gen(:,1)==casedata.bus(i,1));
end
 
% Initialization of AGCs
for i=1:busesAGC
    switch allSpecsAGC{2,i}
        case 'isolAGC'
            agc(i).compParamLocation=cat(2,[pathStr,allSpecsAGC{3,i},'.txt']); % Reads the location of parameter file of generators that act as voltage sources (synchronous generators) and assigns the file name to 'compParamLocation' property of the parent class 'Components'
            agc(i).agcOutputLocation=cat(2,[pathStr,allSpecsAGC{4,i},'.txt']); % Reads the location of generator states recording file and assigns the file name to 'genOutputLocation' property of the class 'genrou' which is inherited from the 'Components' class
            [agc(i),stRead]=ReadData(agc(i));                             % Calls the member function ReadData() of the 'Components' class to parse the generator parameter file
            agc(i)=AssignParams(agc(i));                                  % Calls the member function AssignParams() of the 'genrou' class to assign the generator parameters to 'genrou' class properties
            agc(i)=Init(agc(i));            % Calls the Init() member function of 'genrou' class to initialize the synchronous generator
            agc(i)=WriteData(agc(i));                                     % Calls the WriteData() member function of 'genrou' class to write the states to the states recording file specified in the 'power_plant_specs' text file
            ace=0; % right now the program assumes that there is only one AGC
        case 'interConnecAGC'
            sprintf('%s','to be added')
        otherwise
            sprintf('%s','no AGC in the system')
    end
end
efds=[];
for i=1:busesV
    vs(i)=0;
    switch allSpecsV{2,i}
        case 'genrou'
            genROU(i).compParamLocation=cat(2,[pathStr,allSpecsV{3,i},'.txt']); % Reads the location of parameter file of generators that act as voltage sources (synchronous generators) and assigns the file name to 'compParamLocation' property of the parent class 'Components'
            genROU(i).genOutputLocation=cat(2,[pathStr,allSpecsV{4,i},'.txt']); % Reads the location of generator states recording file and assigns the file name to 'genOutputLocation' property of the class 'genrou' which is inherited from the 'Components' class
            [genROU(i),stRead]=ReadData(genROU(i));                             % Calls the member function ReadData() of the 'Components' class to parse the generator parameter file
            genROU(i)=AssignParams(genROU(i));                                  % Calls the member function AssignParams() of the 'genrou' class to assign the generator parameters to 'genrou' class properties
            eD=real(V_PV(i));                                                   % D axis voltage of the synchronously rotating voltage frame
            eQ=imag(V_PV(i));                                                   % Q axis voltage of the synchronously rotating voltage frame
            iD=(sBasePF/genROU(i).sbgen)*real(I_PV(i));                         % D axis current of the synchronously rotating voltage frame
            iQ=(sBasePF/genROU(i).sbgen)*imag(I_PV(i));                         % Q axis current of the synchronously rotating voltage frame
            [genROU(i),pMech(i),ifd(i)]=Init(genROU(i),eD,eQ,iD,iQ);            % Calls the Init() member function of 'genrou' class to initialize the synchronous generator
            genROU(i)=WriteData(genROU(i));                                     % Calls the WriteData() member function of 'genrou' class to write the states to the states recording file specified in the 'power_plant_specs' text file
            sbgen(i)=genROU(i).sbgen;
            efds=cat(1,efds,ifd(i));
        case 'gensal'
            genSAL(i).compParamLocation=cat(2,[pathStr,allSpecsV{3,i},'.txt']); % Similar set of steps as for genrou
            genSAL(i).genOutputLocation=cat(2,[pathStr,allSpecsV{4,i},'.txt']);
            [genSAL(i),stRead]=ReadData(genSAL(i));
            genSAL(i)=AssignParams(genSAL(i));
            eD=real(V_PV(i));
            eQ=imag(V_PV(i));
            iD=(sBasePF/genSAL(i).sbgen)*real(I_PV(i));
            iQ=(sBasePF/genSAL(i).sbgen)*imag(I_PV(i));
            [genSAL(i),pMech(i),ifd(i)]=Init(genSAL(i),eD,eQ,iD,iQ);
            genSAL(i)=WriteData(genSAL(i));
            sbgen(i)=genSAL(i).sbgen;
            efds=cat(1,efds,ifd(i));
        case 'gencls'
            genCLS(i).compParamLocation=cat(2,[pathStr,allSpecsV{3,i},'.txt']); % Similar set of steps as for genrou
            genCLS(i).genOutputLocation=cat(2,[pathStr,allSpecsV{4,i},'.txt']);
            [genCLS(i),stRead]=ReadData(genCLS(i));
            genCLS(i)=AssignParams(genCLS(i));
            sbgen(i)=genCLS(i).sbgen;
            [genCLS(i),pMech(i)]=Init(genCLS(i),I_PV(i)*sBasePF/sbgen(i),V_PV(i));
            genCLS(i)=WriteData(genCLS(i));
        otherwise
            sprintf('%s','model unavailable. fatal error. Program will terminate')
            break
    end
    
    switch allSpecsV{5,i}
        case 'st1a'
            extST1A(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            extST1A(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [extST1A(i),stRead]=ReadData(extST1A(i));
            extST1A(i)=AssignParams(extST1A(i));
            [extST1A(i),vref(i)]=Init(extST1A(i),ifd(i),vt(i));
            extST1A(i)=WriteData(extST1A(i));
            efd(i)=ifd(i);                                                       % At the time of initialization, exciter generated field voltage and generator field current are equal
        case 'dc1a'
            extDC1A(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            extDC1A(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [extDC1A(i),stRead]=ReadData(extDC1A(i));
            extDC1A(i)=AssignParams(extDC1A(i));
            [extDC1A(i),vref(i)]=Init(extDC1A(i),ifd(i),vt(i));
            efd(i)=ifd(i);
            extDC1A(i)=WriteData(extDC1A(i),efd(i));
        case 'ac1a'
            extAC1A(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            extAC1A(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [extAC1A(i),stRead]=ReadData(extAC1A(i));
            extAC1A(i)=AssignParams(extAC1A(i));
            [extAC1A(i),vref(i)]=Init(extAC1A(i),ifd(i),vt(i));
            efd(i)=ifd(i);
            extAC1A(i)=WriteData(extAC1A(i),efd(i));
        case 'ac7b'
            extAC7B(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            extAC7B(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [extAC7B(i),stRead]=ReadData(extAC7B(i));
            extAC7B(i)=AssignParams(extAC7B(i));
            [extAC7B(i),vref(i)]=Init(extAC7B(i),ifd(i),vt(i));
            efd(i)=ifd(i);
            extAC7B(i)=WriteData(extAC7B(i),ifd(i));
        case 'ieeex1'
            ieeeX1(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            ieeeX1(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [ieeeX1(i),stRead]=ReadData(ieeeX1(i));
            ieeeX1(i)=AssignParams(ieeeX1(i));
            [ieeeX1(i),vref(i)]=Init(ieeeX1(i),ifd(i),vt(i),vs(i));
            efd(i)=ifd(i);
            ieeeX1(i)=WriteData(ieeeX1(i),ifd(i));
        case 'ieeet3'
            ieeeT3(i).compParamLocation=cat(2,[pathStr,allSpecsV{6,i},'.txt']); % Similar set of steps as for genrou
            ieeeT3(i).extOutputLocation=cat(2,[pathStr,allSpecsV{7,i},'.txt']);
            [ieeeT3(i),stRead]=ReadData(ieeeT3(i));
            ieeeT3(i)=AssignParams(ieeeT3(i));
            [ieeeT3(i),vref(i)]=Init(ieeeT3(i),ifd(i),V_PV(i),vs(i),I_PV(i),ifd(i));
            efd(i)=ifd(i);
            ieeeT3(i)=WriteData(ieeeT3(i),ifd(i));
        case 'n/a'
            efd(i)=ifd(i);                                                      % If no exciter is present then, field voltage stays at the initial value which is equal to the generator field current
        otherwise
            sprintf('%s','model unavailable. If exciter is not available for this generator specify ''n/a'' in the power plant specification file. fatal error. Program will terminate')
            break
    end
    
    switch allSpecsV{8,i}
        case 'ggov1'
            govGGOV1(i).compParamLocation=cat(2,[pathStr,allSpecsV{9,i},'.txt']); % Similar set of steps as for genrou
            govGGOV1(i).govOutputLocation=cat(2,[pathStr,allSpecsV{10,i},'.txt']);
            [govGGOV1(i),stRead]=ReadData(govGGOV1(i));
            govGGOV1(i)=AssignParams(govGGOV1(i));
            [govGGOV1(i),pref(i)]=Init(govGGOV1(i),sbgen(i),pMech(i)); % during initialization pmech=pelec. Therefore, pmech from generator initialization is passed here.
            govGGOV1(i)=WriteData(govGGOV1(i));
            sbturb(i)=govGGOV1(i).sbturb;
        case 'hygov'
            govHYGOV(i).compParamLocation=cat(2,[pathStr,allSpecsV{9,i},'.txt']); % Similar set of steps as for genrou
            govHYGOV(i).govOutputLocation=cat(2,[pathStr,allSpecsV{10,i},'.txt']);
            [govHYGOV(i),stRead]=ReadData(govHYGOV(i));
            govHYGOV(i)=AssignParams(govHYGOV(i));
            [govHYGOV(i),pref(i)]=Init(govHYGOV(i),sbgen(i),pMech(i)); % during initialization pmech=pelec. Therefore, pmech from generator initialization is passed here.
            govHYGOV(i)=WriteData(govHYGOV(i));
            sbturb(i)=govHYGOV(i).sbturb;
        case 'ieesgo'
            ieeSGO(i).compParamLocation=cat(2,[pathStr,allSpecsV{9,i},'.txt']); % Similar set of steps as for genrou
            ieeSGO(i).govOutputLocation=cat(2,[pathStr,allSpecsV{10,i},'.txt']);
            [ieeSGO(i),stRead]=ReadData(ieeSGO(i));
            ieeSGO(i)=AssignParams(ieeSGO(i));
            [ieeSGO(i),pref(i)]=Init(ieeSGO(i),sbgen(i),pMech(i)); % during initialization pmech=pelec. Therefore, pmech from generator initialization is passed here.
            ieeSGO(i)=WriteData(ieeSGO(i));
            sbturb(i)=ieeSGO(i).sbturb;
        case 'n/a'
            pMmechGov(i)=pMech(i); % Since mechanical power will not change if a turbine/governor is absent, we can store the turbine mechanical power on the generator base. Otherwise, we will have to perform unnecessary floating point calculations for conversion to turbine base from generator base and vice-versa
        otherwise
            sprintf('%s','model unavailable. If governor is not available for this generator specify ''n/a'' in the power plant specification file. fatal error. Program will terminate')
            break
    end
    
    switch allSpecsV{20,i}
        case 'unit_controller'
            uCnt(i).compParamLocation=cat(2,[pathStr,allSpecsV{21,i},'.txt']); % Similar set of steps as for genrou
            uCnt(i).uCntOutputLocation=cat(2,[pathStr,allSpecsV{22,i},'.txt']);
            [uCnt(i),stRead]=ReadData(uCnt(i));
            uCnt(i)=AssignParams(uCnt(i));
            uCnt(i)=Init(uCnt(i)); % during initialization pmech=pelec. Therefore, pmech from generator initialization is passed here.
            uCnt(i)=WriteData(uCnt(i));
        otherwise
            sprintf('%s','no generator has a unit controller...this is incorrect if AGC is present...check the power_plant_specs file');
    end
    % store governor ratings of generators on AGC
    for kkkk=1:count
        if (genBusAGC(kkkk,1)==str2double(allSpecsV{1,i}))
            genBusAGC(kkkk,3)=sbturb(i);
            break;
        end
    end
end
 
 
 
 
%% busesI is the counter for current sources and the section of code here initializes all the current sources. At present wind and solar power plant models are the only current sources modeled
for i=1:busesI
    switch allSpecsI{2,i}
        case 'regc'
            regc(i).compParamLocation=cat(2,[pathStr,allSpecsI{3,i},'.txt']); % Similar set of steps as for genrou
            regc(i).regcOutputLocation=cat(2,[pathStr,allSpecsI{4,i},'.txt']);
            [regc(i),stRead]=ReadData(regc(i));
            regc(i)=AssignParams(regc(i));
            [regc(i),ipcmd0(i),iqcmd0(i)]=Init(regc(i),I_I(i)*sBasePF/regc(i).mvab,V_I(i),qgen(i)*sBasePF/regc(i).mvab);
            regcMVA=cat(1,regcMVA,[str2double(allSpecsI{1,i}) regc(i).mvab]);
            % NOTES on the Init() member function of class 'regc'
            %   1.  The power base for 'regc' model can be different from the power flow MVA base. Therefore, currents and powers are
            %       converted to the 'regc' base for initializing the 'regc' model
            %   2.  ipcmd0(i) and iqcmd0(i) are vectors that store the initial value of real and reactive power control commands, respectively, out of the REEC_A or the REEC_B model
            %
            regc(i)=WriteData(regc(i));
        case 'genrouCS'
            genROUCS(i).compParamLocation=cat(2,[pathStr,allSpecsI{3,i},'.txt']); % Reads the location of parameter file of generators that act as voltage sources (synchronous generators) and assigns the file name to 'compParamLocation' property of the parent class 'Components'
            genROUCS(i).genOutputLocation=cat(2,[pathStr,allSpecsI{4,i},'.txt']); % Reads the location of generator states recording file and assigns the file name to 'genOutputLocation' property of the class 'genrou' which is inherited from the 'Components' class
            [genROUCS(i),stRead]=ReadData(genROUCS(i));                             % Calls the member function ReadData() of the 'Components' class to parse the generator parameter file
            genROUCS(i)=AssignParams(genROUCS(i));                                  % Calls the member function AssignParams() of the 'genrou' class to assign the generator parameters to 'genrou' class properties
            eD=real(V_I(i));                                                   % D axis voltage of the synchronously rotating voltage frame
            eQ=imag(V_I(i));                                                   % Q axis voltage of the synchronously rotating voltage frame
            iD=(sBasePF/genROUCS(i).sbgen)*real(I_I(i));                         % D axis current of the synchronously rotating voltage frame
            iQ=(sBasePF/genROUCS(i).sbgen)*imag(I_I(i));                         % Q axis current of the synchronously rotating voltage frame
            genROUCS(i).sbgen=genROUCS(i).sbgen;
            [genROUCS(i),pMechCS(i),ifdCS(i)]=Init(genROUCS(i),eD,eQ,iD,iQ);            % Calls the Init() member function of 'genrou' class to initialize the synchronous generator
            genROUCS(i)=WriteData(genROUCS(i));                                     % Calls the WriteData() member function of 'genrou' class to write the states to the states recording file specified in the 'power_plant_specs' text file
            sbgenCS(i)=genROUCS(i).sbgen;
            efds=cat(1,efds,ifdCS(i));
        otherwise
            sprintf('%s','model unavailable. fatal error. Program will terminate') % For any wind or solar PV model, 'regc' must be present otherwise the user made an error
            break
    end
    
    switch allSpecsI{5,i}
        case 'type3'
            reecA(i).compParamLocation=cat(2,[pathStr,allSpecsI{6,i},'.txt']);
            reecA(i).reecOutputLocation=cat(2,[pathStr,allSpecsI{7,i},'.txt']);
            [reecA(i),stRead]=ReadData(reecA(i));
            reecA(i)=AssignParams(reecA(i));
            
            % force reec MVA to be equal to regc MVA
            for j=1:length(regcMVA(i))
                if str2double(allSpecsI{1,i})==regcMVA(i,1)
                    reecA(i).mvab=regcMVA(i,2);
                    break;
                end
            end
            
            % change pmax of reec models for wind and solar
            for j=1:length(pmaxData)
                if str2double(allSpecsI{1,i})==pmaxData(j,1)
                    reecA(i).pmax=pmaxData(j,2)/reecA(i).mvab;
                    reecA(i).pmin=pmaxData(j,3)/reecA(i).mvab;
                    break;
                end
            end
            % Initialization of 'REEC_A' model for type 3 wind turbines requires the shaft speed at steady state which should be
            % obtained from the 'wtgtq_a' model.
            
            wtgtq(i).compParamLocation=cat(2,[pathStr,allSpecsI{12,i},'.txt']);
            wtgtq(i).wtgtqOutputLocation=cat(2,[pathStr,allSpecsI{13,i},'.txt']);
            [wtgtq(i),stRead]=ReadData(wtgtq(i));
            wtgtq(i)=AssignParams(wtgtq(i));
            
            if pe(i)*sBasePF/reecA(i).mvab>=0 && pe(i)*sBasePF/reecA(i).mvab<wtgtq(i).p1
                wref=wtgtq(i).spd1;
            elseif pe(i)*sBasePF/reecA(i).mvab>=wtgtq(i).p1 && pe(i)*sBasePF/reecA(i).mvab<wtgtq(i).p2
                wref=wtgtq(i).spd1+(pe(i)-wtgtq(i).p1)*(wtgtq(i).spd2-wtgtq(i).spd1)/(wtgtq(i).p2-wtgtq(i).p1);
            elseif pe(i)*sBasePF/reecA(i).mvab>=wtgtq(i).p2 && pe(i)*sBasePF/reecA(i).mvab<wtgtq(i).p3
                wref=wtgtq(i).spd2+(pe(i)-wtgtq(i).p2)*(wtgtq(i).spd3-wtgtq(i).spd2)/(wtgtq(i).p3-wtgtq(i).p2);
            elseif pe(i)*sBasePF/reecA(i).mvab>=wtgtq(i).p3 && pe(i)*sBasePF/reecA(i).mvab<wtgtq(i).p4
                wref=wtgtq(i).spd3+(pe(i)-wtgtq(i).p3)*(wtgtq(i).spd4-wtgtq(i).spd3)/(wtgtq(i).p4-wtgtq(i).p3);
            else
                wref=wtgtq(i).spd4;
            end
            wg(i)=wref;     % At steady state, generator shaft speed = 'wref' obtained from the 'wtgtq_a' model
            
            iqcmd(i)=iqcmd0(i)*regc(i).mvab/reecA(i).mvab; % iqcmd0(i) and ipcmd0(i) as obtained from the 'regc' model above, are on the base of 'regc'.
            % Since the 'reecA' or 'reecB' model initialization uses these values, these must be converted to 'REEC_A or B' base
            
            ipcmd(i)=ipcmd0(i)*regc(i).mvab/reecA(i).mvab;
            [reecA(i),pord(i),qext(i),pref0(i)]=Init(reecA(i),ipcmd(i),iqcmd(i),vterm(i),wg(i),qgen(i)*sBasePF/reecA(i).mvab,pe(i)*sBasePF/reecA(i).mvab); % pord is not used in Type 4 Wind Turbines
            % pord(i) -  stores the initial power order for the 'wtgpt' model
            % qext(i) -  stores the initial reactive power reference signal of the 'repc' model
            % pref0(i) - stores the initial active power reference signal of the 'wtgtq' model
            reecA(i)=WriteData(reecA(i));
        case 'type4'
            reecA(i).compParamLocation=cat(2,[pathStr,allSpecsI{6,i},'.txt']);
            reecA(i).reecOutputLocation=cat(2,[pathStr,allSpecsI{7,i},'.txt']);
            [reecA(i),stRead]=ReadData(reecA(i));
            reecA(i)=AssignParams(reecA(i));
            
            % force reec MVA to be equal to regc MVA
            for j=1:length(regcMVA(i))
                if str2double(allSpecsI{1,i})==regcMVA(i,1)
                    reecA(i).mvab=regcMVA(i,2);
                    break;
                end
            end           
            
            % change pmax of reec models for wind and solar
            for j=1:length(pmaxData)
                if str2double(allSpecsI{1,i})==pmaxData(j,1)
                    reecA(i).pmax=pmaxData(j,2)/reecA(i).mvab;
                    reecA(i).pmin=pmaxData(j,3)/reecA(i).mvab;
                    break;
                end
            end
            
            if strcmp(allSpecsI{8,i},'n/a')==1      % This condition if true implies Type 4B wind turbine generator, otherwise it is Type 4A wind turbine generator
                wg(i)=1;
            else
                wtgtr(i).compParamLocation=cat(2,[pathStr,allSpecsI{9,i},'.txt']);
                wtgtr(i).wtgtrOutputLocation=cat(2,[pathStr,allSpecsI{10,i},'.txt']);
                [wtgtr(i),stRead]=ReadData(wtgtr(i));
                wtgtr(i)=AssignParams(wtgtr(i));
                wg(i)=wtgtr(i).w0;
                [wtgtr(i),theta(i)]=Init(wtgtr(i),pe(i)*sBasePF/wtgtr(i).mvab,wg(i)); % theta(i) is not used for Type 4 wind turbines as 'wtgpt_a' model is not used in these turbines
            end
            
            % change pmax of reec models for wind and solar
            for j=1:length(pmaxData)
                if str2double(allSpecsI{1,i})==pmaxData(j,1)
                    reecA(i).pmax=pmaxData(j,2)/reecA(i).mvab;
                    reecA(i).pmin=pmaxData(j,3)/reecA(i).mvab;
                    break;
                end
            end                  
            
            iqcmd(i)=iqcmd0(i)*regc(i).mvab/reecA(i).mvab;
            ipcmd(i)=ipcmd0(i)*regc(i).mvab/reecA(i).mvab;
            [reecA(i),pord(i),qext(i),pref0(i)]=Init(reecA(i),ipcmd(i),iqcmd(i),vterm(i),wg(i),qgen(i)*sBasePF/reecA(i).mvab,pe(i)*sBasePF/reecA(i).mvab); % pord is not used in Type 4 Wind Turbines
            % pref0(i) - In the case of Type 4 turbines, pref0(i) is the active power reference signal of the 'repc'
            %            model as the 'wtgtq' model is not used with these turbines
            reecA(i)=WriteData(reecA(i));
        case 'centpv'
            reecB(i).compParamLocation=cat(2,[pathStr,allSpecsI{6,i},'.txt']);
            reecB(i).reecOutputLocation=cat(2,[pathStr,allSpecsI{7,i},'.txt']);
            [reecB(i),stRead]=ReadData(reecB(i));
            reecB(i)=AssignParams(reecB(i));
 
            % force reec MVA to be equal to regc MVA
            for j=1:length(regcMVA)
                if str2double(allSpecsI{1,i})==regcMVA(j,1)
                    reecA(i).mvab=regcMVA(j,2);
                    break;
                end
            end            
            
            % change pmax of reec models for wind and solar
            for j=1:length(pmaxData)
                if str2double(allSpecsI{1,i})==pmaxData(j,1)
                    reecB(i).pmax=pmaxData(j,2)/reecB(i).mvab;
                    reecB(i).pmin=pmaxData(j,3)/reecB(i).mvab;
                    countreecB=countreecB+1;
                    reecpmaxpmin=cat(1,reecpmaxpmin,[str2double(allSpecsI{1,i}),reecB(i).pmax,reecB(i).pmin,reecB(i).mvab]);                    
                    break;
                end
            end            
            
            iqcmd(i)=iqcmd0(i)*regc(i).mvab/reecB(i).mvab;
            ipcmd(i)=ipcmd0(i)*regc(i).mvab/reecB(i).mvab;
            [reecB(i),qext(i),pref0(i)]=Init(reecB(i),ipcmd(i),iqcmd(i),vterm(i),qgen(i)*sBasePF/reecB(i).mvab,pe(i)*sBasePF/reecB(i).mvab); % pord is not used in central PV Stations
            % pref0(i) - In the case of Type 4 turbines, pref0(i) is the active power reference signal of the 'repc'
            %            model as the 'wtgtq' model is not used with these turbines
            reecB(i)=WriteData(reecB(i));
            
        case 'ac1a'
            extAC1A(i+busesV).compParamLocation=cat(2,[pathStr,allSpecsI{6,i},'.txt']); % Similar set of steps as for genrou
            extAC1A(i+busesV).extOutputLocation=cat(2,[pathStr,allSpecsI{7,i},'.txt']);
            [extAC1A(i+busesV),stRead]=ReadData(extAC1A(i+busesV));
            extAC1A(i+busesV)=AssignParams(extAC1A(i+busesV));
            [extAC1A(i+busesV),vrefCS(i)]=Init(extAC1A(i+busesV),ifdCS(i),vterm(i));
            efdCS(i)=ifdCS(i);
            extAC1A(i+busesV)=WriteData(extAC1A(i+busesV),efdCS(i));
        case 'n/a'
            if strcmp(allSpecsI{2,i},"regc")==1
                iqcmd(i)=iqcmd0(i); % If the 'reecA' or 'reecB' models are not used then the input to the 'regc' model during iterations remains constant and since the initial values were on the 'regc' base, no base conversion is required
                ipcmd(i)=ipcmd0(i);
            elseif strcmp(allSpecsI{2,i},"genrouCS")==1
                efdCS(i)=ifdCS(i);
            end
        otherwise
            sprintf('%s','model unavailable.Specifiy "n/a" in the power_plant_specs file. Program will terminate')
            break
    end
    
    switch allSpecsI{8,i}
        case 'type3'
            if strcmp(allSpecsI{5,i},'n/a')~=1
                wtgtr(i).compParamLocation=cat(2,[pathStr,allSpecsI{9,i},'.txt']);
                wtgtr(i).wtgtrOutputLocation=cat(2,[pathStr,allSpecsI{10,i},'.txt']);
                [wtgtr(i),stRead]=ReadData(wtgtr(i));
                wtgtr(i)=AssignParams(wtgtr(i));
                [wtgtr(i),theta(i)]=Init(wtgtr(i),pe(i)*sBasePF/wtgtr(i).mvab,wg(i));  % terminal electric power is converted on the drive train model base for initialization of the drive train model
                wtgtr(i)=WriteData(wtgtr(i));
                
                [wtgtq(i),wref,prefRepc(i)]=Init(wtgtq(i),pref0(i)*reecA(i).mvab/wtgtq(i).mvab,pe(i)*sBasePF/wtgtq(i).mvab);
                % pref0(i) obtained from the initialization of the 'reecA' model is on 'reecA' power base and is converted to the 'wtgtq_a' base for 'wtgtq' model initialization
                % prefRepc(i) is the initial reference active power signal for the 'repc' model
                wtgpt(i).compParamLocation=cat(2,[pathStr,allSpecsI{15,i},'.txt']);
                wtgpt(i).wtgptOutputLocation=cat(2,[pathStr,allSpecsI{16,i},'.txt']);
                [wtgpt(i),stRead]=ReadData(wtgpt(i));
                wtgpt(i)=AssignParams(wtgpt(i));
                
                
                [wtgpt(i),wt]=Init(wtgpt(i),pord(i)*reecA(i).mvab/wtgpt(i).mvab,wref(1),theta(i));
                % pord(i) obtained from the initialization of the 'reecA' model is on 'reecA' power base and is converted to the 'wtgpt_a' base for 'wtgpt' model initialization
                wtgpt(i)=WriteData(wtgpt(i));
                
                if strcmp(allSpecsI{17,i},'repc')==1
                    fbus(i)=i; % this is being set to disable any impact of branch flows. Will fix it later.
                    tbus(i)=i;
                    ckt(i)='1';
                    repc(i).mvab=regc(i).mvab;
                    [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                    vreg=vterm(i); % we are currently forcing vreg to be vterm. Ability to include the impact of flows will be included later
                    freq=1; % this disables primary frequency response from the plant controller. But, AGC control can still work.
                    
                    % This function is called only when the 'repc' model is present. It calculates the regulated bus voltage and monitored branch active and reactive powers
                    % for initialization of the repc model, and later for the generation of the active and reactive power reference signals by the 'repc' model
                    if freq==0 % This condition is tested to ensure that when voltage droop control is implemented, flags in the 'repc' model are at correct values
                        repc(i).refflag=1;
                        repc(i).freqflag=0;
                    end
                    repc(i).compParamLocation=cat(2,[pathStr,allSpecsI{18,i},'.txt']);
                    repc(i).repcOutputLocation=cat(2,[pathStr,allSpecsI{19,i},'.txt']);
                    [repc(i),stRead]=ReadData(repc(i));
                    repc(i)=AssignParams(repc(i));
 
                    % force repc MVA to be equal to regc MVA
                    for j=1:length(regcMVA(i))
                        if str2double(allSpecsI{1,i})==regcMVA(j,1)
                            repc(i).mvab=regcMVA(j,2);
                            break;
                        end
                    end
                    
                    % change pmax of repc models for wind and solar
                    for j=1:length(pmaxData)
                        if str2double(allSpecsI{1,i})==pmaxData(j,1)
                            repc(i).pmax=pmaxData(j,2)/repc(i).mvab;
                            repc(i).pmin=pmaxData(j,3)/repc(i).mvab;
                            break;
                        end
                    end
                    
                    repc(i)=Init(repc(i),prefRepc(i)*wtgtq(i).mvab/repc(i).mvab,qext(i)*reecA(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq);
                    % prefRepc(i) calculated from the 'wtgtq' model above is on 'wtgtq' power base and is converted to 'repc' power base for initialization
                    repc(i)=WriteData(repc(i));
                    repcMVA(i)=repc(i).mvab;
                    repcMW(i)=repcMVA(i)*repc(i).pmax;
                end
            end
        case 'type4'
            if strcmp(allSpecsI{5,i},'n/a')~=1
                if strcmp(allSpecsI{17,i},'repc')==1
                    fbus(i)=i; % this is ebign ste to disable any impact of branch flows. Will fix it later.
                    tbus(i)=i;
                    ckt(i)='1';
                    [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                    vreg=vterm(i); % we are currently forcing vreg to be vterm. Ability to include the impact of flows will be included later
                    freq=1; % this disables primary frequency response from the plant controller. But, AGC control can still work.
                    if freq==0
                        repc(i).refflag=1;
                        repc(i).freqflag=0;
                    end
                    repc(i).compParamLocation=cat(2,[pathStr,allSpecsI{18,i},'.txt']);
                    repc(i).repcOutputLocation=cat(2,[pathStr,allSpecsI{19,i},'.txt']);
                    [repc(i),stRead]=ReadData(repc(i));
                    repc(i)=AssignParams(repc(i));
 
                    % force repc MVA to be equal to regc MVA
                    for j=1:length(regcMVA(i))
                        if str2double(allSpecsI{1,i})==regcMVA(j,1)
                            repc(i).mvab=regcMVA(j,2);
                            break;
                        end
                    end                    
                    
                    % change pmax of repc models for wind and solar
                    for j=1:length(pmaxData)
                        if str2double(allSpecsI{1,i})==pmaxData(j,1)
                            repc(i).pmax=pmaxData(j,2)/repc(i).mvab;
                            repc(i).pmin=pmaxData(j,3)/repc(i).mvab;
                            break;
                        end
                    end
                    
                    prefRepc(i)=pref0(i); % In the case of Type 4 turbines pref0(i) and prefRepc(i) are equal as the active power reference signal is sent directly to 'reecA' model from the 'repc' model.
                    repc(i)=Init(repc(i),pref0(i)*reecA(i).mvab/repc(i).mvab,qext(i)*reecA(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq);
                    repc(i)=WriteData(repc(i));
                    repcMVA(i)=repc(i).mvab;
                    repcMW(i)=repcMVA(i)*repc(i).pmax;
                else
                    prefRepc(i)=pref0(i);                           % if the 'repc' model is absent then pref0(i) will remain fixed during the iterations and hence it is directly assigned to prefRepc(i) as pref0(i) is already on 'reecA' base
                end
            end
        case 'centpv'
            if strcmp(allSpecsI{5,i},'n/a')~=1
                repc(i).compParamLocation=cat(2,[pathStr,allSpecsI{18,i},'.txt']);
                repc(i).repcOutputLocation=cat(2,[pathStr,allSpecsI{19,i},'.txt']);
                [repc(i),stRead]=ReadData(repc(i));
                repc(i)=AssignParams(repc(i));
                
                % force repc MVA to be equal to regc MVA
                for j=1:length(regcMVA)
                    if str2double(allSpecsI{1,i})==regcMVA(j,1)
                        repc(i).mvab=regcMVA(j,2);
                        break;
                    end
                end
                % change pmax of repc models for wind and solar
                for j=1:length(pmaxData)
                    if str2double(allSpecsI{1,i})==pmaxData(j,1)
                            repc(i).pmax=pmaxData(j,2)/repc(i).mvab;
                            repc(i).pmin=pmaxData(j,3)/repc(i).mvab;
                            countrepc=countrepc+1;
                            repcpmaxpmin=cat(1,repcpmaxpmin,[str2double(allSpecsI{1,i}),repc(i).pmax,repc(i).pmin,repc(i).mvab]);
                        break;
                    end
                end
                
                fbus(i)=i; % this is being set to disable any impact of branch flows. Will fix it later.
                tbus(i)=i;
                ckt(i)='1';
                [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                vreg=vterm(i); % we are currently forcing vreg to be vterm. Ability to include the impact of flows will be included later
                freq=1; % this disables primary frequency response from the plant controller. But, AGC control can still work.
                if freq==0
                    repc(i).refflag=1;
                    repc(i).freqflag=0;
                end
                repc(i)=Init(repc(i),pref0(i)*reecB(i).mvab/repc(i).mvab,qext(i)*reecB(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq);
                prefRepc(i)=pref0(i);  % same comment as for 'type4' wind generator above
                repc(i)=WriteData(repc(i));
                repcMVA(i)=repc(i).mvab;
                repcMW(i)=repcMVA(i)*repc(i).pmax;
            end
        case 'n/a'
            if strcmp(allSpecsI{5,i},'n/a')~=1 && strcmp(allSpecsI{17,i},'repc')==1  % even if the 8th field is 'n/a' for a Type 4 wind turbine 'repc' can still be
                % present. But presence of 'repc' will make sense only if 'reecA' or 'reecB'
                % are present. This if-else statement checks for these conditions
                repc(i).compParamLocation=cat(2,[pathStr,allSpecsI{18,i},'.txt']);
                repc(i).repcOutputLocation=cat(2,[pathStr,allSpecsI{19,i},'.txt']);
                [repc(i),stRead]=ReadData(repc(i));
                repc(i)=AssignParams(repc(i));
                
                % force repc MVA to be equal to regc MVA
                for j=1:length(regcMVA)
                    if str2double(allSpecsI{1,i})==regcMVA(j,1)
                        repc(i).mvab=regcMVA(j,2);
                        break;
                    end
                end
                
                % change pmax of repc models for wind and solar
                for j=1:length(pmaxData)
                    if str2double(allSpecsI{1,i})==pmaxData(j,1)
                            repc(i).pmax=pmaxData(j,2)/repc(i).mvab;
                            repc(i).pmin=pmaxData(j,3)/repc(i).mvab;
                        break;
                    end
                end
                
                prefRepc(i)=pref0(i);  % same comment as for 'type4' wind generator above
                fbus(i)=i; % this is being set to disable any impact of branch flows. Will fix it later.
                tbus(i)=i;
                ckt(i)='1';
                [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                vreg=vterm(i); % we are currently forcing vreg to be vterm. Ability to include the impact of flows will be included later
                freq=1; % this disables primary frequency response from the plant controller. But, AGC control can still work.
                if freq==0
                    repc(i).refflag=1;
                    repc(i).freqflag=0;
                end
                repc(i)=Init(repc(i),pref0(i)*reecA(i).mvab/repc(i).mvab,qext(i)*reecA(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq);
                repc(i)=WriteData(repc(i));
                repcMVA(i)=repc(i).mvab;
                repcMW(i)=repcMVA(i)*repc(i).pmax;
            elseif strcmp(allSpecsI{5,i},'n/a')~=1 && strcmp(allSpecsI{17,i},'repc')~=1 && strcmp(allSpecsI{2,i},'regc')==1
                prefRepc(i)=pref0(i);
            end
        otherwise
            sprintf('%s','model unavailable.Specifiy "n/a" in the power_plant_specs file. Program will terminate')
            break
    end
    
    switch allSpecsI{20,i}
        case 'unit_controller'
            if strcmp(allSpecsI{5,i},'n/a')==1 || strcmp(allSpecsI{8,i},'n/a')==1
                sprintf('%s','Since reec and repc models are absent, this plant cannot be on AGC. Check the power_plant_specs file');
                continue
            end
            uCnt(i+busesV).compParamLocation=cat(2,[pathStr,allSpecsI{21,i},'.txt']); % Similar set of steps as for genrou
            uCnt(i+busesV).uCntOutputLocation=cat(2,[pathStr,allSpecsI{22,i},'.txt']);
            [uCnt(i+busesV),stRead]=ReadData(uCnt(i+busesV));
            uCnt(i+busesV)=AssignParams(uCnt(i+busesV));
            uCnt(i+busesV)=Init(uCnt(i+busesV));
            uCnt(i+busesV)=WriteData(uCnt(i+busesV));
    end
    % store repc ratings of generators on AGC
    for kkkk=1:count
        if (genBusAGC(kkkk,1)==str2double(allSpecsI{1,i}))
            genBusAGC(kkkk,3)=repcMW(i);
            break;
        end
    end    
end
 
 
 
% allocation factors for gens on the basis of available headroom
for kkkk=1:count
    genBusAGC(kkkk,4)=(genBusAGC(kkkk,3)-genBusAGC(kkkk,2))/sum((genBusAGC(:,3)-genBusAGC(:,2)));
    if (genBusAGC(kkkk,4)<0) % this condition may arise if there are small errors in FESTIV that cause pgen of solar to exceed its pmax slightly.
        genBusAGC(kkkk,4)=0; 
    end
end
 
% assign allocation factor to unit controllers
count1=0;
listuCnt=[];
for i=1:length(uCnt)
    if (~isempty(uCnt(i).allocFactor))
       count1=count1+1;
       uCnt(i).allocFactor=genBusAGC(count1,4);
       listuCnt=cat(1,listuCnt,i);
    end
end
%% Running the Dynamics Simulation for updating Component States
%  The sections of the code above this line are run only once per
%  simulation and they could well be put into a separate function. The code
%  in this section is run for a user defined number of iterations
tic
flginit=1;                  % flginit is set to 1 because previous iteration voltages are to be used for the load flow in the next iteration
if isempty(busnumI)
    pinitI=0;
    qinitI=0;
    vPVNew=V_PV;
else
    pinitI=-pe*sBasePF;     % pinitI is a vector and holds the wind or PV generator's equivalent real power injection in MW
    qinitI=-qgen*sBasePF;   % qinitI is a vector and holds the wind or PV generator's equivalent reactive power injection in MW
    vPVNew=V_PV;
end
statesdiff1=[];
 
%%Find the bus that has the AGC on it
for j=1:busesAGC
    for i=1:(busesV+busesI)
        if strcmp(allSpecsAGC{1,j},allSpecs{1,i})==1
            AGCbus(j)=i;
        end
    end
end
%%
 
for iter=1:iterMax
    vOld=V; % voltages from previous iteration
    angVOld(1,:)=atan2(imag(vOld),real(vOld));%;-angVSwing;
    angall(iter,1:2)=angVOld(1:2);
    fprintf('\nIteration %d starting!',iter);
    tspan=[(iter-1)/sampRate iter/sampRate];
    simTime=tspan(1);
    % Simulating step load change. This step may not be necessary for
    % frequency regulation studies if the effects of changes in load on
    % frequency regulation are to be studied; load must be changed in the
    % power flow file for such studies.
    
    % At present, the only current sources are the wind and PV generators and we model their power flow representation as an equivalent
    % P & Q injection at each iteration. The P & Q values are calculated using present iteration's terminal voltage and the new current calculated
    % by the 'regc_a' model. If dynamic models of other current injectors (such as dynamic loads) are added later, constant Z model can also be used.
    % This will require passing additional documents to the runpfDS.m file so that P,Q representation of wind generators and constant impedance
    % representation of dynamic loads is correctly distinguished in the power flow.
    [success,V,I,Ybus1,loadNew,genbus,pq,idxTripGen,angVSwing] = runpfDS(casedata,vPVNew,V_PQ,flag,dBus,sD,flginit,pinitI,qinitI,busnumI,simTime,genTripBus,genTripTime);
    vNew=V; % voltages from current iteration
    angVNew(1,:)=atan2(imag(vNew),real(vNew));%-angVSwing;
    angVector=cat(1,angVOld,angVNew);
    angVectorUnwrap=unwrap(angVector);
    % calculating frequency for specific buses, specifically for the ones
    % that
    frequency1=(120*pi+(angVectorUnwrap(2,filtFreqBus)-angVectorUnwrap(1,filtFreqBus))/(1/sampRate))/(2*pi);
    if iter==1
        freqfilt(iter,:)=frequency1;
    else
        for fcal=1:2
            [T,ffilt]=ode45(@(t,x) fcalc(t,x,frequency1(fcal)),tspan,freqfilt(iter-1,fcal));
            freqfilt(iter,fcal)=ffilt(end);
        end
    end
    % Voltage and Current of Buses that act as voltage sources
    V_PV=V(busnumV);
    I_PV=I(busnumV);
    vt(1:length(V_PV),1)=abs(V_PV);
    
    
    % Voltage of Load Buses that will be passed to the load flow as initial voltages for solving the power flow at the next iteration
    V_PQ=V(pq);
    
    % Voltage and Current of Buses that act as current sources
    if ~isempty(busnumI)
        V_I=V(busnumI);
        I_I=I(busnumI);
        vterm=abs(V_I);
        qgen=imag(V_I.*conj(I_I));
        pe=real(V_I.*conj(I_I));
    end
    %%  
    if iter>=dTimeBegin*sampRate && iter<=dTimeEnd*sampRate
        flag=1;
        sD=[0*loadOrg(dBus,1), 0*loadOrg(dBus,2)];
    else
        flag=0;
        sD=loadOrg(dBus,:);
    end
    
    disturbance_bus_load=[disturbance_bus_load;sD];
    
    % Calculating ACE w/ AGC
    for i=1:busesAGC
        switch allSpecsAGC{2,i}
            case 'isolAGC'
                fm=freqfilt(iter,find(AGCbus(i)==filtFreqBus));
                [agc(i),ace] = newStates(agc(i),tspan,fm);
                if (mod(iter,sampRate/10)==0)
                    agc(i)=WriteData(agc(i));
                end
            case 'interConnecAGC'
        end
    end
    
    for i=1:busesV
        if ((genTripBus==str2double(allSpecsV{1,i}) && simTime>genTripTime))
            vPVNew(i,1)=V(idxTripGen);
            continue
        else
            switch allSpecsV{2,i}
                case 'genrou'
                    delta=genROU(i).genStates(6);
                    ed=real(V_PV(i)*exp(-1i*(delta-pi/2)));
                    eq=imag(V_PV(i)*exp(-1i*(delta-pi/2)));
                    id=(sBasePF/genROU(i).sbgen)*real(I_PV(i)*exp(-1i*(delta-pi/2)));
                    if isnan(id)
                        id;
                    end
                    iq=(sBasePF/genROU(i).sbgen)*imag(I_PV(i)*exp(-1i*(delta-pi/2)));
                    if iter==1
                        oldstates=genROU(i).genStates';
                    else
                        oldstates=genROU(i).genStates;
                    end
                    [genROU(i),eq1,ed1,ifd(i)] = newStates(genROU(i),tspan,pMech(i),id,iq,ed,eq,efd(i)); % Evaluating Generator States
                    statesdiff=oldstates-genROU(i).genStates;
                    statesdiff1=[statesdiff1 ;statesdiff];
                    if abs(statesdiff(1)) > 1e-10
                        statesdiff;
                    end
                    ed=ed1;
                    eq=eq1;
                    vPVNew(i,1)=(ed+1i*eq)*exp(1i*((genROU(i).genStates(6)-pi/2))); % This conversion of voltages from dq0 frame to abc frame is based on Park's Transformation under balanced system conditions
                    if i==2
                        edqall(iter,:)=[ed eq];
                    end
                    pElec=ed*id+eq*iq;                                              % pElec is the terminal real power, NOT the internal power generated by the synchronous generator.
                    % The internal power is psid*iq-psiq*id=ed*id+eq*iq+ra*(id^2+iq^2) and includes the stator ohmic losses.
                    % pElec is used as the input to the GGOV1 governor
                    
                    wr=genROU(i).genStates(5)/ws;                                   % wr is the relative angular speed of the generator that is used as an input for governors
                    if (mod(iter,sampRate/10)==0)
                        genROU(i)=WriteData(genROU(i));
                    end
                    frequency(iter,i)=genROU(i).genStates(5)/(2*pi);
                case 'gensal'
                    delta=genSAL(i).genStates(5);                                   % Similar comments as for Genrou
                    ed=real(V_PV(i)*exp(-1i*(delta-pi/2)));
                    eq=imag(V_PV(i)*exp(-1i*(delta-pi/2)));
                    id=(sBasePF/genSAL(i).sbgen)*real(I_PV(i)*exp(-1i*(delta-pi/2)));
                    iq=(sBasePF/genSAL(i).sbgen)*imag(I_PV(i)*exp(-1i*(delta-pi/2)));
                    [genSAL(i),eq1,ed1,ifd(i)] = newStates(genSAL(i),tspan,pMech(i),id,iq,ed,eq,efd(i)); % Evaluating Generator States
                    ed=ed1;
                    eq=eq1;
                    vPVNew(i,1)=(ed+1i*eq)*exp(1i*((genSAL(i).genStates(5)-pi/2)));
                    pElec=ed*id+eq*iq;
                    wr=genSAL(i).genStates(4)/ws;
                    if (mod(iter,sampRate/10)==0)
                        genSAL(i)=WriteData(genSAL(i));
                    end
                    frequency(iter,i)=genSAL(i).genStates(4)/(2*pi);
                case 'gencls'
                    peleccg=real(V_PV(i)*conj(I_PV(i)*sBasePF/sbgen(i)));
                    if iter==1
                        oldstates=genCLS(i).genStates';
                    else
                        oldstates=genCLS(i).genStates;
                    end
                    [genCLS(i),vPVNew(i,1)] = newStates(genCLS(i),tspan,pMech(i),I_PV(i)*sBasePF/sbgen(i),peleccg);
                    statesdiff=oldstates-genCLS(i).genStates;
                    if abs(statesdiff(1)) > 1e-10
                        statesdiff;
                    end
                    if (mod(iter,sampRate/10)==0)
                        genCLS(i)=WriteData(genCLS(i));
                    end
                    frequency(iter,i)=genCLS(i).genStates(1)/(2*pi);
            end
            switch allSpecsV{5,i}
                case 'st1a'
                    [extST1A(i),efd(i)]=newStates(extST1A(i),tspan,vref(i),ifd(i),vpss,vt(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        extST1A(i)=WriteData(extST1A(i));
                    end
                case 'ac7b'
                    [extAC7B(i),efd(i)]=newStates(extAC7B(i),tspan,vref(i),ifd(i),vpss,vt(i),efd(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        extAC7B(i)=WriteData(extAC7B(i),efd(i));
                    end
                case 'ac1a'
                    [extAC1A(i),efd(i)]=newStates(extAC1A(i),tspan,vref(i),ifd(i),vpss,vt(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        extAC1A(i)=WriteData(extAC1A(i),efd(i));
                    end
                case 'dc1a'
                    [extDC1A(i),efd(i)]=newStates(extDC1A(i),tspan,vref(i),vpss,vt(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        extDC1A(i)=WriteData(extDC1A(i),efd(i));
                    end
                case 'ieeex1'
                    [ieeeX1(i),efd(i)]=newStates(ieeeX1(i),tspan,vref(i),vpss,vt(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        ieeeX1(i)=WriteData(ieeeX1(i),efd(i));
                    end
                case 'ieeet3'
                    [ieeeT3(i),efd(i)]=newStates(ieeeT3(i),tspan,vref(i),vpss,V_PV(i),I_PV(i),ifd(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                    if (mod(iter,sampRate/10)==0)
                        ieeeT3(i)=WriteData(ieeeT3(i),efd(i));
                    end
            end
            
            switch allSpecsV{20,i}
                case 'unit_controller'
                    [uCnt(i),dpref(i)] = newStates(uCnt(i),tspan,ace,sbturb(i));
                    if (mod(iter,sampRate/10)==0)
                        uCnt(i)=WriteData(uCnt(i));
                    end
                    
            end
            
            switch allSpecsV{8,i}
                case 'ggov1'
                    pElecGov=pElec*sbgen(i)/govGGOV1(i).sbturb;                                  % pElec on turbine/governor power base
                    [govGGOV1(i),pmech]=newStates(govGGOV1(i),tspan,pref(i)+dpref(i),pElecGov,wr);        % Evaluating Governor States
                    pMech(i)=pmech*govGGOV1(i).sbturb/sbgen(i);                                  % pmech is converted to generator's power base
                    if (mod(iter,sampRate/10)==0)
                        govGGOV1(i)=WriteData(govGGOV1(i));
                    end
                case 'hygov'
                    [govHYGOV(i),pmech]=newStates(govHYGOV(i),tspan,pref(i)+dpref(i),wr);        % Evaluating Governor States
                    pMech(i)=pmech*govHYGOV(i).sbturb/sbgen(i);                         % pmech is converted to generator's power base
                    if (mod(iter,sampRate/10)==0)
                        govHYGOV(i)=WriteData(govHYGOV(i));
                    end
                case 'ieesgo'
                    [ieeSGO(i),pmech]=newStates(ieeSGO(i),tspan,pref(i)+dpref(i),wr);        % Evaluating Governor States
                    pMech(i)=pmech*ieeSGO(i).sbturb/sbgen(i);                         % pmech is converted to generator's power base
                    if (mod(iter,sampRate/10)==0)
                        ieeSGO(i)=WriteData(ieeSGO(i));
                    end
            end
        end
    end
    frequency(iter,MAXGEN+1)=mean(frequency(iter,1:MAXGEN));
    voltages2=[voltages2 vPVNew];
    %%
    vt=abs(vPVNew);
    vterminal(iter,1:size(vt,1))=vt';
    %%
    for i=1:busesI
        if (dBus==str2double(allSpecs{1,busnumI(i)}) && simTime>=dTimeBegin)
            pinitI(i)=0;
            qinitI(i)=0;
            sD=[0 0];
            continue;
        end
        switch allSpecsI{2,i}
            case 'regc'
                if strcmp(allSpecsI{5,i},'n/a')==1
                    [regc(i),inet]=newStates(regc(i),tspan,V_I(i),ipcmd(i),iqcmd(i));
                elseif strcmp(allSpecsI{5,i},'centpv')~=1
                    [regc(i),inet]=newStates(regc(i),tspan,V_I(i),ipcmd(i)*reecA(i).mvab/regc(i).mvab,iqcmd(i)*reecA(i).mvab/regc(i).mvab);
                elseif strcmp(allSpecsI{5,i},'centpv')==1
                    [regc(i),inet]=newStates(regc(i),tspan,V_I(i),ipcmd(i)*reecB(i).mvab/regc(i).mvab,iqcmd(i)*reecB(i).mvab/regc(i).mvab);
                end
                pinitI(i)=-real((inet*regc(i).mvab/sBasePF)*conj(V_I(i)))*100; % The updated network current injection from wind or PV generators, inet,
                % is converted into equivalent P and Q injection in MW for the powerflow
                qinitI(i)=imag((inet*regc(i).mvab/sBasePF)*conj(V_I(i)))*100;
                if (mod(iter,sampRate/10)==0)
                    regc(i)=WriteData(regc(i));
                end
            case 'genrouCS'
                delta=genROUCS(i).genStates(6);
                ed=real(V_I(i)*exp(-1i*(delta-pi/2)));
                eq=imag(V_I(i)*exp(-1i*(delta-pi/2)));
                id=(sBasePF/genROUCS(i).sbgen)*real(I_I(i)*exp(-1i*(delta-pi/2)));
                iq=(sBasePF/genROUCS(i).sbgen)*imag(I_I(i)*exp(-1i*(delta-pi/2)));
                if iter==1
                    oldstates=genROUCS(i).genStates';
                else
                    oldstates=genROUCS(i).genStates;
                end
                [genROUCS(i),id,iq,ifdCS(i)] = newStates(genROUCS(i),tspan,pMechCS(i),id,iq,ed,eq,efdCS(i)); % Evaluating Generator States
                inet=(id+1i*iq)*exp(1i*((genROUCS(i).genStates(6)-pi/2))); % This conversion of voltages from dq0 frame to abc frame is based on Park's Transformation under balanced system conditions
                pinitI(i)=-real((inet*genROUCS(i).sbgen/sBasePF)*conj(V_I(i)))*100;                                              % pElec is the terminal real power, NOT the internal power generated by the synchronous generator.
                qinitI(i)=imag((inet*genROUCS(i).sbgen/sBasePF)*conj(V_I(i)))*100;
                wr=genROUCS(i).genStates(5)/ws;                                   % wr is the relative angular speed of the generator that is used as an input for governors
                if (mod(iter,sampRate/10)==0)
                    genROUCS(i)=WriteData(genROUCS(i));
                end
                frequencyCS(iter,i)=genROUCS(i).genStates(5)/(2*pi);
        end
        
        switch allSpecsI{5,i}
            case 'type3'
                [reecA(i),iqcmd(i),ipcmd(i),pord(i)]=newStates(reecA(i),tspan,pe(i)*sBasePF/reecA(i).mvab,wg(i),vterm(i),qext(i),qgen(i)*sBasePF/reecA(i).mvab,pref0(i),ipcmd(i),iqcmd(i));
                if (mod(iter,sampRate/10)==0)
                    reecA(i)=WriteData(reecA(i));
                end
            case 'type4'
                [reecA(i),iqcmd(i),ipcmd(i),pord(i)]=newStates(reecA(i),tspan,pe(i)*sBasePF/reecA(i).mvab,wg(i),vterm(i),qext(i),qgen(i)*sBasePF/reecA(i).mvab,prefRepc(i),ipcmd(i),iqcmd(i));
                if (mod(iter,sampRate/10)==0)
                    reecA(i)=WriteData(reecA(i));
                end
            case 'centpv'
                [reecB(i),iqcmd(i),ipcmd(i)]=newStates(reecB(i),tspan,pe(i)*sBasePF/reecB(i).mvab,vterm(i),qext(i),qgen(i)*sBasePF/reecB(i).mvab,prefRepc(i),ipcmd(i),iqcmd(i));
                if (mod(iter,sampRate/2)==0)
                    reecB(i)=WriteData(reecB(i));
                end
            case 'ac1a'
                [extAC1A(i+busesV),efdCS(i)]=newStates(extAC1A(i+busesV),tspan,vrefCS(i),ifdCS(i),vpss,vterm(i)); % Evaluating Exciter States; vpss is a place holder for the power system stabilizer output voltage
                if (mod(iter,sampRate/10)==0)
                    extAC1A(i+busesV)=WriteData(extAC1A(i+busesV),efdCS(i));
                end
        end
        
        switch allSpecsI{20,i}
            case 'unit_controller'
                if (repcMW(i)==0)
                    continue
                else
                    [uCnt(i+busesV),dprefCS(i)] = newStates(uCnt(i+busesV),tspan,ace,repcMW(i));
                end
                if (mod(iter,sampRate/10)==0)
                    uCnt(i+busesV)=WriteData(uCnt(i+busesV));
                end
                
        end
        
        
        switch allSpecsI{8,i}
            case 'type3'
                if strcmp(allSpecsI{5,i},'n/a')~=1      % This condition ensures that if the reec_a model is absent, then even if the user erroneously
                    % connects other models to the type3 wind turbine, these models are not executed.
                    [wtgtr(i),wt(i),wg(i)]=newStates(wtgtr(i),tspan,pe(i)*sBasePF/wtgtr(i).mvab,theta(i));
                    if (mod(iter,sampRate/2)==0)
                        wtgtr(i)=WriteData(wtgtr(i));
                    end
                    
                    [wtgtq(i),pref0(i)]=newStates(wtgtq(i),tspan,pe(i)*sBasePF/wtgtq(i).mvab,wg(i),reecA(i).voltage_dip,prefRepc(i));
                    if (mod(iter,sampRate/2)==0)
                        wtgtq(i)=WriteData(wtgtq(i));
                    end
                    wref=wtgtq(i).wtgtqStates(2);
                    
                    [wtgpt(i),theta(i)]=newStates(wtgpt(i),tspan,pord(i)*reecA(i).mvab/wtgpt(i).mvab,wref,wt(i));
                    if (mod(iter,sampRate/2)==0)
                        wtgpt(i)=WriteData(wtgpt(i));
                    end
                    
                    if strcmp(allSpecsI{17,i},'repc')==1
                        fbus(i)=i; % this is ebign ste to disable any impact of branch flows. Will fix it later.
                        tbus(i)=i;
                        ckt(i)='1';                        
                        [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                        vreg=vterm(i);
                        freq=1;
                        [repc(i),preftemp,qext(i)]=newStates(repc(i),tspan,prefRepc(i)*wtgtq(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq,dprefCS(i));
                        if preftemp~=0                                         % Even if the 'repc' model is present, the 'freqflg' flag may be set to zero 
                            % In this case, prefRepc(i) should not be changed from its initial value and so should the 'pref0' property of 'wtgpt_a' model
                            % as both the 'wtgtq_a' and 'wtgpt_a' models receive their power reference input from 'repc_a' model.
                            prefRepc(i)=preftemp*repc(i).mvab/wtgtq(i).mvab;
                            wtgpt(i).pref0=prefRepc(i)*wtgtq(i).mvab/wtgpt(i).mvab;
                        end
                        qext(i)=qext(i)*repc(i).mvab/reecA(i).mvab;
                        if (mod(iter,sampRate/2)==0)
                            repc(i)=WriteData(repc(i));
                        end
                    end
                end
            case 'type4'
                [wtgtr(i),wt(i),wg(i)]=newStates(wtgtr(i),tspan,pe(i)*sBasePF/wtgtr(i).mvab,theta(i));
                if strcmp(allSpecsI{5,i},'n/a')~=1
                    if strcmp(allSpecsI{17,i},'repc')==1
                        fbus(i)=i; % this is ebign ste to disable any impact of branch flows. Will fix it later.
                        tbus(i)=i;
                        ckt(i)='1';                           
                        [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                        vreg=vterm(i);
                        freq=1;
                        [repc(i),prefRepc(i),qext(i)]=newStates(repc(i),tspan,prefRepc(i)*reecA(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq,dprefCS(i));
                        prefRepc(i)=prefRepc(i)*repc(i).mvab/reecA(i).mvab;
                        qext(i)=qext(i)*repc(i).mvab/reecA(i).mvab;
                        if (mod(iter,sampRate/2)==0)
                            repc(i)=WriteData(repc(i));
                        end
                    end
                end
                if (mod(iter,sampRate/2)==0)
                    wtgtr(i)=WriteData(wtgtr(i));
                end
            case 'centpv'
                if strcmp(allSpecsI{5,i},'n/a')~=1
                    if strcmp(allSpecsI{17,i},'repc')==1
                        fbus(i)=i; % this is ebign ste to disable any impact of branch flows. Will fix it later.
                        tbus(i)=i;
                        ckt(i)='1';                           
                        [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                        vreg=vterm(i);
                        freq=1;
                        [repc(i),prefRepc(i),qext(i)]=newStates(repc(i),tspan,prefRepc(i)*reecB(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq,dprefCS(i));
                        prefRepc(i)=prefRepc(i)*repc(i).mvab/reecB(i).mvab;
                        qext(i)=qext(i)*repc(i).mvab/reecB(i).mvab;
                        if (mod(iter,sampRate/2)==0)
                            repc(i)=WriteData(repc(i));
                        end
                    end
                end
                if (mod(iter,sampRate/2)==0)
                    repc(i)=WriteData(repc(i));
                end
            case 'n/a'
                if strcmp(allSpecsI{5,i},'n/a')~=1 && strcmp(allSpecsI{17,i},'repc')==1
                    fbus(i)=i; % this is ebign ste to disable any impact of branch flows. Will fix it later.
                    tbus(i)=i;
                    ckt(i)='1';
                    [vreg,ibranch,pbranch,qbranch,freq]=repcpfinp(fbus(i),tbus(i),ckt(i),V,Ybus,deltat);
                    vreg=vterm(i);
                    freq=1;
                    [repc(i),prefRepc(i),qext(i)]=newStates(repc(i),tspan,prefRepc(i)*reecA(i).mvab/repc(i).mvab,ibranch*sBasePF/repc(i).mvab,vreg,qbranch*sBasePF/repc(i).mvab,pbranch*sBasePF/repc(i).mvab,freq,dprefCS(i));
                    prefRepc(i)=prefRepc(i)*repc(i).mvab/reecA(i).mvab;
                    qext(i)=qext(i)*repc(i).mvab/reecA(i).mvab;
                    if (mod(iter,sampRate/2)==0)
                        repc(i)=WriteData(repc(i));
                    end
                end
                
        end
        if strcmp(allSpecsI{2,i},"regc")==1
            ipcmdd(iter,1:length(ipcmd))=ipcmd;
            iqcmdd(iter,1:length(iqcmd))=iqcmd;
        end
        vterminal(iter,size(vt,1)+1:size(vt,1)+size(vterm,1))=vterm'; % vterminal is made to store terminal voltage rms magnitudes for wind and pv buses as well
    end    
end
fclose('all');
toc
figure;plot(frequency);

